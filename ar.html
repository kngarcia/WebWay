<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>AR - WebWay</title>
  
  <!-- Solo A-Frame y Three.js - sin AR.js problem√°tico -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.2.0/aframe.min.js"></script>
  
  <!-- Componente GPS simple para A-Frame -->
  <script>
    // Componente GPS simplificado
    AFRAME.registerComponent('simple-gps', {
      schema: {
        latitude: {type: 'number', default: 0},
        longitude: {type: 'number', default: 0}
      },
      init: function() {
        this.updatePosition();
      },
      update: function() {
        this.updatePosition();
      },
      updatePosition: function() {
        const lat = this.data.latitude;
        const lon = this.data.longitude;
        // Conversi√≥n simple de coordenadas GPS a posici√≥n 3D
        const x = (lon - this.el.sceneEl.systems.gps.currentLon) * 111320;
        const z = -(lat - this.el.sceneEl.systems.gps.currentLat) * 111320;
        this.el.setAttribute('position', {x: x, y: 0, z: z});
      }
    });

    // Sistema GPS
    AFRAME.registerSystem('gps', {
      init: function() {
        this.currentLat = 0;
        this.currentLon = 0;
        this.watchId = null;
        this.startGPS();
      },
      startGPS: function() {
        if (!navigator.geolocation) return;
        
        this.watchId = navigator.geolocation.watchPosition(
          (position) => {
            this.currentLat = position.coords.latitude;
            this.currentLon = position.coords.longitude;
            // Actualizar todas las entidades GPS
            this.el.sceneEl.querySelectorAll('[simple-gps]').forEach(el => {
              el.components['simple-gps'].updatePosition();
            });
          },
          (error) => console.error('GPS Error:', error),
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 10000 }
        );
      }
    });
  </script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #333;
      border-top: 5px solid #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .ar-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      width: 90%;
      max-width: 400px;
    }
    
    .info-panel {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 1rem;
      border-radius: 15px;
      margin-bottom: 1rem;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      width: 100%;
    }
    
    .btn-secondary {
      background: #666;
      color: white;
    }
    
    /* Estilos para la c√°mara manual */
    #manual-video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 1;
      display: none;
    }
    
    #ar-scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2;
    }
  </style>
</head>
<body>
  <!-- Video para la c√°mara -->
  <video id="manual-video" autoplay playsinline></video>

  <!-- Escena A-Frame sin AR.js -->
  <a-scene id="ar-scene" style="display: none;" gps>
    <!-- C√°mara -->
    <a-camera look-controls="enabled: true" wasd-controls="enabled: false">
      <!-- Flecha de navegaci√≥n como hijo de la c√°mara (siempre en vista) -->
      <a-entity 
        id="arrow"
        geometry="primitive: cone; height: 2; radiusBottom: 0.5"
        material="color: #FF3366; metalness: 0.3; roughness: 0.7"
        position="0 0 -5"
        scale="2 2 2"
        visible="false"
      ></a-entity>
    </a-camera>
    
    <!-- Entidades de prueba -->
    <a-entity id="test-marker" simple-gps="latitude: 0; longitude: 0" geometry="primitive: box" material="color: blue" scale="1 1 1" visible="false"></a-entity>
  </a-scene>

  <!-- Loading -->
  <div id="loading" class="loading">
    <div class="spinner"></div>
    <p>Inicializando navegaci√≥n AR...</p>
  </div>

  <!-- Panel de control -->
  <div class="ar-controls">
    <div id="info" class="info-panel">
      <h3>Navegaci√≥n AR</h3>
      <p>Preparando...</p>
    </div>
    <button id="back-btn" class="btn btn-secondary" onclick="window.location.href='index.html'">
      ‚Üê Volver al Men√∫
    </button>
  </div>

  <script>
    // Sistema de c√°mara manual y AR simplificado
    class SimpleARNavigation {
      constructor() {
        this.video = document.getElementById('manual-video');
        this.scene = document.getElementById('ar-scene');
        this.loading = document.getElementById('loading');
        this.infoDiv = document.getElementById('info');
        this.destino = null;
        this.watchId = null;
        
        this.init();
      }

      async init() {
        try {
          console.log('üöÄ Iniciando navegaci√≥n AR simplificada...');
          
          // Cargar destino
          await this.cargarDestino();
          
          // Iniciar c√°mara
          await this.iniciarCamara();
          
          // Iniciar GPS
          this.iniciarGPS();
          
          // Mostrar escena
          this.scene.style.display = 'block';
          this.loading.style.display = 'none';
          
          console.log('‚úÖ Navegaci√≥n AR lista');
          
        } catch (error) {
          console.error('‚ùå Error:', error);
          this.mostrarError('Error: ' + error.message);
        }
      }

      cargarDestino() {
        return new Promise((resolve, reject) => {
          try {
            const destinoData = localStorage.getItem('ar-destino');
            if (!destinoData) {
              reject(new Error('No se encontr√≥ destino seleccionado'));
              return;
            }
            
            this.destino = JSON.parse(destinoData);
            console.log('üìç Destino:', this.destino.Nombre);
            this.actualizarInfo(`üìç <b>${this.destino.Nombre}</b><br>Iniciando c√°mara...`);
            resolve();
            
          } catch (error) {
            reject(new Error('Error cargando destino: ' + error.message));
          }
        });
      }

      async iniciarCamara() {
        try {
          console.log('üì∑ Solicitando permisos de c√°mara...');
          
          const stream = await navigator.mediaDevices.getUserMedia({ 
            video: {
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            },
            audio: false
          });
          
          this.video.srcObject = stream;
          this.video.style.display = 'block';
          
          // Esperar a que el video est√© listo
          await new Promise((resolve) => {
            this.video.onloadedmetadata = () => {
              this.video.play();
              resolve();
            };
          });
          
          console.log('‚úÖ C√°mara iniciada correctamente');
          
        } catch (error) {
          console.error('‚ùå Error de c√°mara:', error);
          throw new Error(this.getCameraErrorMessage(error));
        }
      }

      getCameraErrorMessage(error) {
        switch(error.name) {
          case 'NotAllowedError':
            return 'Permiso de c√°mara denegado. Por favor, permite el acceso a la c√°mara.';
          case 'NotFoundError':
            return 'No se encontr√≥ c√°mara trasera. Usando c√°mara frontal.';
          case 'NotSupportedError':
            return 'Tu navegador no soporta acceso a la c√°mara.';
          default:
            return 'Error accediendo a la c√°mara: ' + error.message;
        }
      }

      iniciarGPS() {
        if (!navigator.geolocation) {
          this.mostrarError('Geolocalizaci√≥n no soportada');
          return;
        }

        console.log('üåç Iniciando GPS...');
        
        this.watchId = navigator.geolocation.watchPosition(
          (position) => this.actualizarPosicion(position),
          (error) => this.manejarErrorGPS(error),
          {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 10000
          }
        );
      }

      actualizarPosicion(position) {
        const userLat = position.coords.latitude;
        const userLon = position.coords.longitude;
        
        console.log(`üì° Posici√≥n: ${userLat.toFixed(6)}, ${userLon.toFixed(6)}`);
        
        const distancia = this.calcularDistancia(userLat, userLon, this.destino.Latitud, this.destino.Longitud);
        const rumbo = this.calcularRumbo(userLat, userLon, this.destino.Latitud, this.destino.Longitud);
        
        this.actualizarInterfaz(distancia, rumbo);
        this.actualizarFlecha(rumbo, distancia);
        
        if (distancia < 10) {
          this.llegadaDestino();
        }
      }

      calcularDistancia(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const œÜ1 = lat1 * Math.PI / 180;
        const œÜ2 = lat2 * Math.PI / 180;
        const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                 Math.cos(œÜ1) * Math.cos(œÜ2) *
                 Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
      }

      calcularRumbo(lat1, lon1, lat2, lon2) {
        const œÜ1 = lat1 * Math.PI / 180;
        const œÜ2 = lat2 * Math.PI / 180;
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

        const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
        const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                 Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
        const Œ∏ = Math.atan2(y, x);

        return (Œ∏ * 180 / Math.PI + 360) % 360;
      }

      actualizarInterfaz(distancia, rumbo) {
        let distanciaTexto;
        if (distancia < 1000) {
          distanciaTexto = `${Math.round(distancia)} metros`;
        } else {
          distanciaTexto = `${(distancia/1000).toFixed(1)} km`;
        }

        this.actualizarInfo(`
          <strong>${this.destino.Nombre}</strong><br>
          üìè Distancia: ${distanciaTexto}<br>
          üß≠ Direcci√≥n: ${Math.round(rumbo)}¬∞<br>
          <small>Apunta la c√°mara hacia la direcci√≥n indicada</small>
        `);
      }

      actualizarFlecha(rumbo, distancia) {
        const arrow = document.getElementById('arrow');
        if (!arrow) return;

        // Convertir rumbo a rotaci√≥n (ajustar seg√∫n la orientaci√≥n del dispositivo)
        const rotacion = this.calcularRotacionFlecha(rumbo);
        
        arrow.setAttribute('rotation', {
          x: -90,  // Apuntar hacia adelante
          y: rotacion,
          z: 0
        });
        
        // Escala basada en distancia
        const escala = Math.min(3, Math.max(1, distancia / 50));
        arrow.setAttribute('scale', `${escala} ${escala} ${escala}`);
        
        arrow.setAttribute('visible', 'true');
      }

      calcularRotacionFlecha(rumbo) {
        // Ajustar la rotaci√≥n basada en la orientaci√≥n del dispositivo
        // Esto es una simplificaci√≥n - en una app real necesitar√≠as el compass
        return (rumbo + 180) % 360;
      }

      llegadaDestino() {
        this.actualizarInfo(`
          <div style="color: #4CAF50;">
            <strong>üéâ ¬°Has llegado!</strong><br>
            ${this.destino.Nombre}
          </div>
        `);
        
        const arrow = document.getElementById('arrow');
        if (arrow) arrow.setAttribute('visible', 'false');
        
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        
        if (navigator.vibrate) {
          navigator.vibrate([300, 100, 300]);
        }
      }

      manejarErrorGPS(error) {
        let mensaje = 'Error GPS: ';
        switch(error.code) {
          case error.PERMISSION_DENIED:
            mensaje = 'Permiso de ubicaci√≥n denegado. Activa la ubicaci√≥n.';
            break;
          case error.POSITION_UNAVAILABLE:
            mensaje = 'Ubicaci√≥n no disponible. Verifica tu GPS.';
            break;
          case error.TIMEOUT:
            mensaje = 'Tiempo de espera agotado.';
            break;
          default:
            mensaje = error.message;
        }
        this.mostrarError(mensaje);
      }

      actualizarInfo(mensaje) {
        if (this.infoDiv) {
          this.infoDiv.innerHTML = mensaje;
        }
      }

      mostrarError(mensaje) {
        console.error('‚ùå Error:', mensaje);
        this.actualizarInfo(`<div style="color: #ff4444;">${mensaje}</div>`);
      }

      cleanup() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
        }
        if (this.video.srcObject) {
          this.video.srcObject.getTracks().forEach(track => track.stop());
        }
      }
    }

    // Inicializar cuando el DOM est√© listo
    document.addEventListener('DOMContentLoaded', () => {
      window.simpleAR = new SimpleARNavigation();
    });

    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (window.simpleAR) {
        window.simpleAR.cleanup();
      }
    });
  </script>
</body>
</html>