<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>AR Navigation - WebWay</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.2.0/aframe.min.js"></script>
  <!-- AR.js sin detecci√≥n de marcadores, solo GPS -->
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
  
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    .loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #000; color: white; display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 1000;
    }
    .spinner {
      width: 40px; height: 40px; border: 4px solid #333;
      border-top: 4px solid #fff; border-radius: 50%;
      animation: spin 1s linear infinite; margin-bottom: 20px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }
    }
    .info-panel {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9); color: white; padding: 15px;
      border-radius: 10px; z-index: 1000; max-width: 90%; text-align: center;
    }
    .btn { padding: 10px 20px; background: #666; color: white; 
           border: none; border-radius: 5px; margin: 5px; cursor: pointer; }
    .debug-info { font-size: 12px; color: #ccc; margin-top: 10px; }
  </style>
</head>
<body>
  <div id="loading" class="loading">
    <div class="spinner"></div>
    <p>Inicializando AR con GPS...</p>
  </div>

  <!-- Escena A-Frame simple SIN AR.js problem√°tico -->
  <a-scene
    vr-mode-ui="enabled: false"
    embedded
    renderer="colorManagement: true;"
    style="width: 100vw; height: 100vh;"
  >
    <!-- C√°mara normal -->
    <a-camera id="main-camera" position="0 1.6 0" wasd-controls="enabled: false">
      <!-- Flecha de direcci√≥n como hijo de la c√°mara (siempre visible) -->
      <a-entity 
        id="direction-arrow"
        geometry="primitive: cone; height: 0.5; radiusBottom: 0.1"
        material="color: #3366FF; metalness: 0.3; roughness: 0.7"
        position="0 0 -1"
        rotation="-90 0 0"
        scale="1 1 1"
        visible="false"
      ></a-entity>
    </a-camera>

    <!-- Sky (fondo) -->
    <a-sky color="#000000"></a-sky>
    
    <!-- Grid para referencia (opcional) -->
    <a-grid position="0 0 0" rotation="-90 0 0" width="10" height="10" color="#333333"></a-grid>
  </a-scene>

  <div id="info" class="info-panel">
    <h3>üöÄ Navegaci√≥n AR con GPS</h3>
    <p>Buscando ubicaci√≥n...</p>
    <div id="debug" class="debug-info"></div>
    <button class="btn" onclick="window.location.href='index.html'">Volver</button>
    <button class="btn" id="test-mode-btn">Modo Prueba (50m)</button>
  </div>

  <script>
    class SimpleARNavigation {
      constructor() {
        this.destino = null;
        this.userPosition = null;
        this.watchId = null;
        this.directionArrow = null;
        this.infoDiv = null;
        this.debugDiv = null;
        this.testMode = false;
        this.testDestination = null;
        this.currentRotation = 0;
        
        this.init();
      }

      async init() {
        try {
          console.log('üöÄ Iniciando navegaci√≥n AR simple...');
          
          await this.cargarDestino();
          this.configurarElementos();
          this.configurarBotones();
          this.iniciarGPS();
          
          setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
          }, 2000);
          
        } catch (error) {
          console.error('‚ùå Error:', error);
          this.mostrarError('Error: ' + error.message);
        }
      }

      cargarDestino() {
        return new Promise((resolve, reject) => {
          try {
            const destinoData = localStorage.getItem('ar-destino');
            if (!destinoData) {
              reject(new Error('No se encontr√≥ destino seleccionado'));
              return;
            }
            
            this.destino = JSON.parse(destinoData);
            console.log('üéØ Destino:', this.destino);
            this.actualizarInfo(`üéØ <b>${this.destino.Nombre}</b><br>Buscando GPS...`);
            resolve();
            
          } catch (error) {
            reject(new Error('Error cargando destino: ' + error.message));
          }
        });
      }

      configurarElementos() {
        this.directionArrow = document.getElementById('direction-arrow');
        this.infoDiv = document.getElementById('info');
        this.debugDiv = document.getElementById('debug');
        
        // Configurar controles de mirada para m√≥vil
        const camera = document.getElementById('main-camera');
        camera.setAttribute('look-controls', {
          enabled: true,
          pointerLockEnabled: false
        });
      }

      configurarBotones() {
        document.getElementById('test-mode-btn').addEventListener('click', () => {
          this.activarModoPrueba();
        });
      }

      activarModoPrueba() {
        if (!this.userPosition) {
          alert('Espera a tener ubicaci√≥n GPS primero');
          return;
        }
        
        this.testMode = true;
        
        const userLat = this.userPosition.coords.latitude;
        const userLon = this.userPosition.coords.longitude;
        
        // Destino a 50 metros al noreste
        this.testDestination = {
          Nombre: `${this.destino.Nombre} (PRUEBA - 50m)`,
          Latitud: userLat + 0.00045,
          Longitud: userLon + 0.00045
        };
        
        this.actualizarInfo(`üîß <b>MODO PRUEBA ACTIVADO</b><br>Destino a 50 metros`);
        console.log('üìç Modo prueba - Destino:', this.testDestination);
      }

      iniciarGPS() {
        if (!navigator.geolocation) {
          this.mostrarError('Geolocalizaci√≥n no soportada');
          return;
        }

        console.log('üåç Iniciando GPS...');
        
        this.watchId = navigator.geolocation.watchPosition(
          (position) => this.actualizarPosicionUsuario(position),
          (error) => this.manejarErrorGPS(error),
          {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 5000
          }
        );
      }

      actualizarPosicionUsuario(position) {
        this.userPosition = position;
        const userLat = position.coords.latitude;
        const userLon = position.coords.longitude;
        const accuracy = position.coords.accuracy;
        
        const destinoActual = this.testMode ? this.testDestination : this.destino;
        
        const distancia = this.calcularDistancia(userLat, userLon, destinoActual.Latitud, destinoActual.Longitud);
        const rumbo = this.calcularRumbo(userLat, userLon, destinoActual.Latitud, destinoActual.Longitud);
        
        this.actualizarInterfaz(distancia, rumbo, destinoActual, accuracy);
        this.actualizarFlechaDireccion(rumbo, distancia);
        
        if (distancia < 15) {
          this.llegadaDestino(destinoActual);
        }
      }

      calcularDistancia(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const œÜ1 = lat1 * Math.PI / 180;
        const œÜ2 = lat2 * Math.PI / 180;
        const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                 Math.cos(œÜ1) * Math.cos(œÜ2) *
                 Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
      }

      calcularRumbo(lat1, lon1, lat2, lon2) {
        const œÜ1 = lat1 * Math.PI / 180;
        const œÜ2 = lat2 * Math.PI / 180;
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

        const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
        const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                 Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
        const Œ∏ = Math.atan2(y, x);

        return (Œ∏ * 180 / Math.PI + 360) % 360;
      }

      actualizarInterfaz(distancia, rumbo, destino, accuracy) {
        let distanciaTexto;
        if (distancia < 1000) {
          distanciaTexto = `${Math.round(distancia)} metros`;
        } else {
          distanciaTexto = `${(distancia/1000).toFixed(1)} km`;
        }

        const modoTexto = this.testMode ? 'üîß MODO PRUEBA' : 'üåç MODO REAL';
        
        this.actualizarInfo(`
          <strong>${destino.Nombre}</strong><br>
          üìè Distancia: ${distanciaTexto}<br>
          üß≠ Direcci√≥n: ${Math.round(rumbo)}¬∞<br>
          <small>${modoTexto} | Precisi√≥n: ¬±${Math.round(accuracy)}m</small>
        `);
        
        // Debug info
        if (this.debugDiv) {
          this.debugDiv.innerHTML = `
            Usuario: ${this.userPosition.coords.latitude.toFixed(6)}, ${this.userPosition.coords.longitude.toFixed(6)}<br>
            Destino: ${destino.Latitud.toFixed(6)}, ${destino.Longitud.toFixed(6)}<br>
            Distancia: ${Math.round(distancia)}m | Rumbo: ${Math.round(rumbo)}¬∞
          `;
        }
      }

      actualizarFlechaDireccion(rumbo, distancia) {
        if (!this.directionArrow) return;
        
        // Calcular rotaci√≥n basada en el rumbo y la orientaci√≥n del dispositivo
        this.currentRotation = this.calcularRotacionRelativa(rumbo);
        
        this.directionArrow.setAttribute('rotation', {
          x: -90,  // Apuntar hacia adelante
          y: this.currentRotation,
          z: 0
        });
        
        // Escala basada en distancia (m√°s grande cuando est√° cerca)
        const escalaBase = 1;
        const escalaDistancia = Math.min(2, Math.max(0.5, 50 / Math.max(distancia, 10)));
        const escalaFinal = escalaBase * escalaDistancia;
        
        this.directionArrow.setAttribute('scale', {
          x: escalaFinal,
          y: escalaFinal,
          z: escalaFinal
        });
        
        this.directionArrow.setAttribute('visible', 'true');
      }

      calcularRotacionRelativa(rumbo) {
        // En una implementaci√≥n real, aqu√≠ integrar√≠as con la br√∫jula del dispositivo
        // Por ahora, usamos el rumbo GPS directamente
        return (rumbo + 180) % 360;
      }

      llegadaDestino(destino) {
        this.actualizarInfo(`
          <div style="color: #4CAF50; font-weight: bold;">
            üéâ ¬°HAS LLEGADO!<br>
            ${destino.Nombre}
          </div>
        `);
        
        if (this.directionArrow) {
          this.directionArrow.setAttribute('visible', 'false');
        }
        
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          this.watchId = null;
        }
        
        // Vibraci√≥n
        if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200, 100, 200]);
        }
        
        // Efecto visual (cambiar color de fondo)
        const sky = document.querySelector('a-sky');
        if (sky) {
          sky.setAttribute('color', '#004400');
          setTimeout(() => sky.setAttribute('color', '#000000'), 2000);
        }
      }

      manejarErrorGPS(error) {
        let mensaje = 'Error GPS: ';
        switch(error.code) {
          case error.PERMISSION_DENIED:
            mensaje = 'Permiso de ubicaci√≥n denegado. Activa la ubicaci√≥n en ajustes.';
            break;
          case error.POSITION_UNAVAILABLE:
            mensaje = 'Ubicaci√≥n no disponible. Verifica tu conexi√≥n GPS.';
            break;
          case error.TIMEOUT:
            mensaje = 'Tiempo de espera agotado. Intenta moverte a un lugar con mejor se√±al.';
            break;
          default:
            mensaje = 'Error de GPS: ' + error.message;
        }
        this.mostrarError(mensaje);
      }

      actualizarInfo(mensaje) {
        if (this.infoDiv) {
          this.infoDiv.innerHTML = mensaje;
        }
      }

      mostrarError(mensaje) {
        console.error('‚ùå Error:', mensaje);
        this.actualizarInfo(`<div style="color: #ff4444;">${mensaje}</div>`);
      }

      cleanup() {
        if (this.watchId) {
          navigator.geolocation.clearWatch(this.watchId);
          console.log('üßπ GPS limpiado');
        }
      }
    }

    // Inicializar cuando el DOM est√© listo
    document.addEventListener('DOMContentLoaded', () => {
      console.log('üöÄ Iniciando aplicaci√≥n AR...');
      window.arNavigation = new SimpleARNavigation();
    });

    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (window.arNavigation) {
        window.arNavigation.cleanup();
      }
    });

    // Manejar orientaci√≥n del dispositivo para mejorar la flecha
    window.addEventListener('deviceorientation', (event) => {
      if (window.arNavigation && event.alpha !== null) {
        // En una implementaci√≥n completa, usar√≠amos la br√∫jula aqu√≠
        // para ajustar la flecha seg√∫n la orientaci√≥n real del dispositivo
      }
    });
  </script>
</body>
</html>